import org.gradle.api.tasks.bundling.Jar
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.Exec
import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.tasks.*
import org.gradle.process.ExecOperations

plugins {
    id("java")
    id("java-library")
    alias(libs.plugins.kotlin)
}

kotlin {
    jvmToolchain(21)
}

dependencies {
    implementation("org.scijava:native-lib-loader:2.5.0")
    testImplementation(kotlin("stdlib-jdk8"))
    testImplementation(libs.junit)
    testImplementation(libs.opentest4j)
}

group = providers.gradleProperty("pluginGroup").get()
version = providers.gradleProperty("pluginVersion").get()

tasks.named("compileJava", JavaCompile::class.java) {
    // Generate JNI headers into `src/main/native`
    options.headerOutputDirectory = layout.projectDirectory.dir("src/main/native")
}

abstract class CmakeBuildTask : DefaultTask() {
    @get:InputDirectory
    @get:PathSensitive(PathSensitivity.RELATIVE)
    abstract val sourceDir: DirectoryProperty
    @get:OutputDirectory
    abstract val buildDir: DirectoryProperty
    @get:InputFile
    abstract val toolchainFile: RegularFileProperty

    @get:Inject
    abstract val execOperations: ExecOperations

    @TaskAction
    fun build() {
        // Configure cmake
        execOperations.exec { // Use execOperations.exec
            workingDir = sourceDir.get().asFile
            commandLine(
                "cmake",
                "-S", sourceDir.get().asFile.absolutePath,
                "-B", buildDir.get().asFile.absolutePath,
                "-DCMAKE_TOOLCHAIN_FILE=${toolchainFile.get().asFile.absolutePath}" // Correct toolchain syntax
            )
        }

        // Run the build
        execOperations.exec { // Use execOperations.exec
            workingDir = sourceDir.get().asFile
            commandLine("cmake", "--build", buildDir.get().asFile.absolutePath)
        }
    }
}

val sharedLibraryPatterns = Action<CopySpec> {
    includeEmptyDirs = false
    include("**/*.so", "**/*.dylib", "**/*.dll")
}

val cmakeSourceDir = layout.projectDirectory.dir("src/main/native")
val cmakeBuildDir = layout.buildDirectory.dir("cmake-jni").get()
val toolchainsDir = layout.projectDirectory.dir("src/main/native/cmake/toolchains/")

data class BuildConfig(
    val arch: String,
    val os: String,
    val buildSubDir: String,
    val toolchainFileName: String,
) {
    // e.g., "buildJni_x86_64-linux"
    val taskId = "buildJni_${arch}-${os}" 
    val buildDir = cmakeBuildDir.dir(buildSubDir)
}

/*
 * See buildSubDir to match path convention of native-lib-loader
 * https://github.com/scijava/native-lib-loader
 */
val allBuildConfigs = listOf(
    BuildConfig("x86_64", "linux", "linux_64", "x86_64-linux-gnu.cmake"),
    BuildConfig("x86_64", "windows", "windows_64", "x86_64-windows-gnu.cmake"),
    BuildConfig("x86_64", "macos", "osx_64", "x86_64-macos-none.cmake"),
    BuildConfig("aarch64", "linux", "linux_arm64", "aarch64-linux-gnu.cmake"),
    BuildConfig("aarch64", "windows", "windows_arm64", "aarch64-windows-gnu.cmake"),
    BuildConfig("aarch64", "macos", "osx_arm64", "aarch64-macos-none.cmake"),
)
val cmakeBuildTaskProviders = mutableListOf<TaskProvider<CmakeBuildTask>>()
allBuildConfigs.forEach { config ->
    val taskProvider = tasks.register<CmakeBuildTask>(config.taskId) {
        group = "build"
        description = "Configures and builds native Zstd JNI for ${config.os}-${config.arch}."
        sourceDir.set(cmakeSourceDir)
        buildDir.set(config.buildDir)
        toolchainFile.set(toolchainsDir.file(config.toolchainFileName))

        // The JNI bindings depends on the JNI header generated by the compileJava
        // task
        dependsOn("compileJava")
    }
    cmakeBuildTaskProviders.add(taskProvider)
}

val buildJniAll = tasks.register("buildJniAll") {
    group = "build"
    description = "Builds JNI bindings for all the supported target platforms and architectures."
    dependsOn(cmakeBuildTaskProviders)
}

/**
 * Determine buildJni_ task for the current platform
 */
val currentOs = when {
    System.getProperty("os.name").contains("Windows", ignoreCase = true) -> "windows"
    System.getProperty("os.name").contains("Mac OS X", ignoreCase = true) -> "macos"
    System.getProperty("os.name").contains("Linux", ignoreCase = true) -> "linux"
    else -> null
}
val currentArch = when (System.getProperty("os.arch")) {
    "amd64", "x86_64" -> "x86_64"
    "aarch64" -> "aarch64"
    else -> null
}

// Find the build config for the current platform
val buildJniCurrentPlatform = allBuildConfigs.find { it.os == currentOs && it.arch == currentArch } ?: throw GradleException("Could not determine a specific JNI build task for current platform: ${System.getProperty("os.name")} - ${System.getProperty("os.arch")}.")

fun Jar.addNativeLibrariesFromCmake() {
    from(cmakeBuildDir) {
        includeEmptyDirs = false
        include("**/*.so", "**/*.dylib", "**/*.dll")
    }
}

tasks.jar {
    dependsOn(buildJniAll) 
    addNativeLibrariesFromCmake()
}

tasks.register<Jar>("jarLocal") {
    group = "build"
    description = "Creates a JAR containing JNI binding libraries for only the current platforms."
    dependsOn(tasks.named(buildJniCurrentPlatform.taskId))
    addNativeLibrariesFromCmake()
}

tasks.test {
    // Make the JNI bindings of the current platform available when running tests
    systemProperty("java.library.path", buildJniCurrentPlatform.buildDir.asFile.absolutePath)
}
